---
title: Ch4.程序的链接
---
## 目标文件格式
### 程序链接概述
#### 链接操作的步骤
1. 确定标号引用关系（符号解析）
2. 合并相关.o文件
3. 确定每个标号的地址
4. 在指令中填入新地址
其中2~3即为**重定位**
#### 使用链接的好处
1. 模块化
	1. 一个程序可以分成很多源程序文件
	2. 可构建公共函数库，如数学库，标准C库等
2. 效率高
	1. 时间上，可分开编译。只需重新编译被修改的源程序文件，然后重新链接
	2. 空间上，无需包含共享库所有代码
#### 链接的本质
合并相同的节
![](../../img/Pasted%20image%2020240403230929.png)
#### 链接操作的步骤
##### 1. 符号解析
1. 编译器将定义的符号存放在一个**符号表**中
2. 符号表的每个表项包括**符号名、长度和位置**等信息。
3. 链接器将每个符号的**引用**都与一个确定的**符号定义**建立关联
##### 2. 重定位
1. 将多个代码段和数据段分别合并为一个单独的代码段和数据段
2. 计算每个定义的符号在虚拟地址空间中的**绝对地址**
3. 将可执行文件中符号引用的地址修改为重定位后的地址信息

### 目标文件
- **目标代码**指编译器和汇编器处理源代码后所生产的机器语言目标代码
- **目标文件**指包含目标代码的文件
目标文件有**三类**：
1. **可重定位目标文件(.o**)
	- 其代码和数据可和其他可重定位文件合并为可执行文件
	- 由对应的.c文件生成
	- 代码和数据地址都**从0开始**
2. **可执行目标文件**(默认为a.out)
	- 包含的代码和数据可以被直接复制到内存并被执行
	- 代码和数据地址为**虚拟地址空间**中的地址
3. **共享目标文件(.so)**
	- 特殊的**可重定位目标文件**，能在装入或运行时被装入到内存并自动被链接
#### ELF
##### 链接视图
- 静态链接库文件由若干个可重定位目标文件组成
- 包含重定位信息（指出哪些符号引用处需要重定位）
节（section）是其中具有相同特征的最小可处理单位
分为
- .text节：代码
- .data节：数据
- .rodata节：只读数据
- .bss节：未初始化数据

###### 文件格式：
![](../../img/Pasted%20image%2020240403233331.png)
###### ELF头
- ELF头位于ELF文件的开始，包含文件结构说明信息。
- 定义了ELF魔数、版本、小端/大端、操作系统平台、**目标文件的类型**、机器结构类型、**程序执行的入口地址**、**程序头表**（段头表）的起始位置和长度、**节头表**的起始位置和长度等
###### 节头表
- 节头表描述了每个节的**节名**、在文件中的**偏移**、**大小**、**访问属性**、对齐方式等
- 节名记录在.shstrtab中，节头表记录了在其中的偏移量。
- 32位系统中，节头表每个表项占40B
##### 执行视图
- 包含代码、数据（已初始化.data和未初始化.bss)
- 定义的所有变量和函数已有确定地址
- 已被重定位
- 可直接执行
###### 文件格式
![](../../img/Pasted%20image%2020240403235907.png)

###### 程序头表
- 程序头表描述可执行文件中的节与虚拟空间中的存储段之间的映射关系
- 一个表项（32B）说明虚拟地址空间中一个连续的段或一个特殊的节

## 符号解析与重定位
- 每个可重定位目标模块m都有一个符号表，包含了m中定义的符号
- 有三种符号
	1. Global symbols（模块内部定义的全局符号）
		- 由模块m定义并能被其他模块引用的符号。如**非static函数和非static得全局变量**
	2. External symbols（外部定义的全局符号）
		- 由其他模块定义并被m引用的全局符号
	3.  Local symbols（本模块的局部符号）
		- 仅由m定义和引用的本地符号。如**带static的函数和全局变量**
### 符号表
![](../../img/Pasted%20image%2020240404114746.png)
符号所在节只能是: .**bss, .data, .text**
### 符号解析
- 目的：将每个模块中引用的符号与某个目标模块中的定义符号建立关联。
- 符号的定义实质：**分配了存储空间**
#### 全局符号
- 函数名和已初始化的全局变量名是**强符号**
- 未初始化的全局变量名是**弱符号**
#### 多重定义符号的处理规则
1. 强符号不能多次定义
2. 若一个符号被定义为一次强符号和多次弱符号，**以强定义为准**
3. 若有多个弱符号定义，则任选其中一个
应尽量避免使用全局变量，若一定要使用应遵守以下规则
1. 尽量使用本地变量(static)
2. 全局变量要赋初值
3. 外部全局变量要使用extern
#### 链接器符号解析过程
![](../../img/Pasted%20image%2020240404122600.png)
![](../../img/Pasted%20image%2020240404123245.png)

### 重定位
1. 合并相同的节
2. 对定义符号进行重定位（确定地址）
3. 对引用符号进行重定位（确定地址）

#### 重定位信息
- 汇编器遇到引用时，生成一个重定位条目
	- 数据引用的重定位条目在.rel_data中
	- 指令在.rel_text中
- 重定位条目格式：
	- ![](../../img/Pasted%20image%2020240404155208.png)
#### R_386_PC32重定位方式
![](../../img/Pasted%20image%2020240404160337.png)
#### R_386_32
![](../../img/Pasted%20image%2020240404161216.png)
### 可执行文件的加载
- 通过调用execve系统调用函数来调用加载器
- 加载器（loader）根据可执行文件的程序（段）头表中的信息，将可执行文件的代码和数据从磁盘“拷贝”到存储器中
- 加载后，将PC（EIP）设定指向Entry point (即符号_start处，通常位于(.text))，最终执行main函数，以启动程序执行
- ![](../../img/Pasted%20image%2020240404161324.png)
## 动态链接
静态库存在一些缺点：
- 主存资源浪费
- 磁盘空间浪费
- 更新困难
解决方案：Shared Libraries
- 只有一个备份
- 动态地在装入时或运行时被加载并链接
- Windows: .dll, Linux: .so

动态链接可以按以下两种方式进行：
1. 在第一次**加载**并运行时进行 (load-time linking).
	- Linux通常由动态链接器(ld-linux.so)自动处理
	- 标准C库 (libc.so) 通常按这种方式动态被链接
2. 在已经开始**运行**后进行(run-time linking).
	- Linux中，通过调用 dlopen()等接口来实现
	- 分发软件包、构建高性能Web服务器等
### 运行时动态链接
![](../../img/Pasted%20image%2020240404163430.png)
### 位置无关代码（PIC）
- 共享库代码是一种PIC：
	- 代码的位置可以是不确定的
	- 即使共享库代码的长度发生变化，也不影响调用它的程序
- 引入PIC的目的是为了链接器无需修改代码即可将共享库加载到任意地址运行
- 所有引用情况
	- 模块内的过程调用、跳转，采用PC相对偏移寻址
	- 模块内数据访问，如模块内的全局变量和静态变量
	- 模块外的过程调用、跳转
	- 模块外的数据访问，如外部变量的访问
	PIC主要解决后两个问题

### 加载时动态链接
![](../../img/Pasted%20image%2020240404163318.png)
![](../../img/Pasted%20image%2020240404163333.png)

#### 1. 模块内部函数调用或跳转
相对偏移寻址即可

#### 2.模块内部数据引用
![](../../img/Pasted%20image%2020240404164022.png)
#### 3.模块外数据引用
![](../../img/Pasted%20image%2020240404164925.png)
找到PC->根据GOT与代码的相对距离找到GOT->根据GOT找到b
#### 4.模块间调用、跳转
![](../../img/Pasted%20image%2020240404165449.png)
![](../../img/Pasted%20image%2020240404225045.png)![](../../img/Pasted%20image%2020240404225053.png)
![](../../img/Pasted%20image%2020240404225101.png)![](../../img/Pasted%20image%2020240404232302.png)