## Cache
程序访问具有局部性，在较短时间间隔内，程序产生的地址往往集中在一个很小范围内，即具有空间局部性和时间局部性。

Cache是一种小容量高速缓冲存储器，**由SRAM组成**，直接存放在CPU芯片内，速度几乎和CPU一样快。
### Cache映射
解决主存空间与Cache空间对应的问题
- 把主存空间划分为大小相等的主存块（Block）
- Cache中存放一个主存块的对应单位成为槽（Slot）或行（Line）
- 将主存块与Cache行按照以下三种方式进行映射
	- 直接：每个主存块映射到Cache的固定行
	- 全相连（Full Associate）：每个主存块映射到Cache的任一行
	- 组相连（Set Associate）：每个主存块映射到Cache固定组中任一行

#### 直接映射
- Cache行号 = 主存块号 mod Cache行数
- 特点：
	- 容易实现，命中时间短
	- 无需考虑淘汰（替换）问题
	- 不够灵活，Cache存储空间得不到充分利用，命中率低
- ![](../../img/Pasted%20image%2020240405181710.png)
- 引入有效位表示开机/复位后cache内信息无效
- ![](../../img/Pasted%20image%2020240406183249.png)

#### 全相联
有空就放
  
#### 组相联
- 结合直接映射和全相联映射的特点
- 将Cache所有行分组，把主存块映射到Cache固定组的任一行中。也即：组间模映射、组内全映射。映射关系为
  - **Cache组号 = 主存块号 mod Cache组数**
- 每组2或4行（称为2-路或4-路组相联）较常用。通常每组4行以上很少用。在较大容量的L2 Cahce和L3 Cahce中使用4-路以上。
#### 缺失率与关联度
![](../../img/Pasted%20image%2020240406184018.png)
### 替换算法
#### FIFO
先进先出
![](../../img/Pasted%20image%2020240406184833.png)
#### LRU
![](../../img/Pasted%20image%2020240406184910.png)
![](../../img/Pasted%20image%2020240406185108.png)
### 写策略
对于写命中，有两种处理方式
- Write through（直写）
	- 同时写Cache和主存单元
	- 写缓冲
- Write back（回写）
	- 只写Cache不写主存，缺失时一次写回
	- 脏位

对于写不命中
- Write Allocate（写分配）
	- 装入Cache，然后更新相应单元
- Not Write Allocate（非写分配）
	- 直接写主存单元，不装入Cache

### Cache和程序性能
- **程序的性能**指执行程序所用的时间
- **程序执行所用时间**与程序执行时访问指令和数据所用的时间有很大关系，而指令和数据的访问时间与cache命中率、命中时间和缺失损失有关
- 对于给定的计算机系统而言，命中时间和缺失损失是确定的，因此，**指令和数据的访存时间**主要由cache命中率决定
- **cache命中率**主要由程序的空间局部性和时间局部性决定。因此，为了提高程序的性能，程序员须编写出具有良好访问局部性的程序

## 虚拟存储
虚拟存储技术的引入用来解决一对矛盾：
- 由于技术和成本等原因，主存容量受到限制
- 系统程序和应用程序要求主存容量越来越大

虚拟存储技术的实质：
- 程序员在比实际主存空间大得多的逻辑地址空间中编写程序
- 程序执行时，把当前需要的程序段和相应的数据块调入主存，其他暂不用的部分存放在磁盘上
- 指令执行时，通过硬件将逻辑地址（也称虚拟地址或虚地址）转化为物理地址（也称主存地址或实地址）
- 在发生程序或数据访问失效(缺页)时，由操作系统进行主存和磁盘之间的信息交换

### 分页式虚拟存储
基本思想：
- 内存被分成固定长且比较小的存储块(**页框、实页、物理页**)
- 每个进程也被划分成固定长的程序块(**页、虚页、逻辑页**)
- 通过**页表(page table)**实现逻辑地址向物理地址转换（Address Mapping ）

#### 页表结构
![](../../img/Pasted%20image%2020240406225254.png)
![](../../img/Pasted%20image%2020240406225413.png)
#### 异常情况
- 缺页
	- Valid（有效位 / 装入位）为 0
	- 从磁盘读到内存，若内存没有空间，则还要从内存选择一页替换到磁盘上，替换算法类似于Cache，采用回写法，淘汰时，根据“dirty”位确定是否要写磁盘
	- 异常处理结束后：当前指令执行被阻塞，当前进程被挂起，处理结束回到原指令继续执行
- 保护违例/访问违例
	- Access Rights (存取权限)与所指定的具体操作不相符
	- 在屏幕上显示“内存保护错”或“访问违例”信息
	- 异常处理结束后：当前指令的执行被阻塞，当前进程被终止
#### 快表（TLB）
![](../../img/Pasted%20image%2020240406225732.png)
![](../../img/Pasted%20image%2020240406225847.png)
![](../../img/Pasted%20image%2020240406230220.png)
![](../../img/Pasted%20image%2020240406230422.png)

### 分段式和段页式虚拟存储
- 分段系统的实现：
	- 程序员或OS将程序模块或数据模块分配给不同的主存段，一个大程序有多个代码段和多个数据段构成，是按照程序的逻辑结构划分而成的多个相对独立的部分。
		- （例如，过程、子程序、数据表、阵列等）
	- 段通常带有段名或基地址，便于编写程序、编译器优化和操作系统调度管理
	- 分段系统将主存空间按实际程序中的段来划分，每个段在主存中的位置记录在段表中，并附以“段长”项
	- 段表由段表项组成，段表本身也是主存中的一个可再定位段
![](../../img/Pasted%20image%2020240406230919.png)

段页式：
- 段、页式结合。程序的虚拟地址空间按模块分段、段内再分页，进入主存仍以页为基本单位
- 用段表和页表（每段一个）进行两级定位管理
- 根据段地址到段表中查阅与该段相应的页表指针，转向页表，然后根据页地址从页表中查到该页在主存中的页框地址，由此再访问到页内某数据

#### 存储保护
- 什么是存储保护？
	- 为避免多道程序相互干扰，防止某程序出错而破坏其他程序的正确性或不合法地访问其他程序或数据区，应对每个程序进行存储保护
- 以下情况发生存储保护错
	- 地址越界（转换得到的物理地址不属于可访问范围）
		- 访问重定位、键保护、环保护
	- 访问越权（访问操作与所拥有的访问权限不符）
		- 页表中设定访问（存取）权限
- 访问属性的设定
	- 数据段可指定R/W或RO；程序段可指定R/E或RO
- 最基本的保护措施：规定各道程序只能访问属于自己所在的存储区和共享区
	- 对于属自己存储区的信息：可读可写
	- 对共享区或已获授权的其他用户信息：可读不可写
	- 对未获授权的信息（如OS内核、页表等）：不可访问
##### 硬件支持
- 至少支持两种运行模式：管理模式和用户模式
- 使一部分CPU状态只能由系统进程读写而不能由用户进程读写：这部分状态包括：User/Supervisor模式位、页表首地址、TLB等。OS内核可以用特殊的指令（一般称为管态指令或特权指令）来写这些状态
- 提供让CPU在管理模式和用户模式相互转换的机制：“异常”和“陷阱”（系统调用）使CPU从用户模式转到管理模式；异常处理中的“返回”指令（return from exception）使CPU从管理状态转到用户状态

## IA-32存储管理
- 按字节编址
- 在保护模式下，IA-32采用段页式虚拟存储管理方式
- 存储地址采用**逻辑地址、线性地址和物理地址**来进行描述，其中，**逻辑地址和线性地址**是虚拟地址的两种不同表示形式，描述的都是4GB虚拟地址空间中的一个存储地址
	- **逻辑地址由48位组成**，**包含16位段选择符和32位段内偏移量（即有效地址）**
	- 线性地址32位（其位数由虚拟地址空间大小决定）
	- 物理地址32位（其位数由存储器总线中的地址线条数决定）

### 段选择符和段寄存器
![](../../img/Pasted%20image%2020240406231834.png)

- 段描述符是一种数据结构，实际上就是段表项，分两类：
	- 用户进程的代码段和数据段描述符
	- 系统控制段描述符，又分两种：
		- 特殊系统控制段描述符，包括：局部描述符表（LDT）描述符和**任务状态段（TSS）**描述符
		- 控制转移类描述符，包括：调用门描述符、任务门描述符、中断门描述符和陷阱门描述符
- 描述符表实际上就是段表，由段描述符组成。有三种类型：
	- **全局描述符表GDT**：只有一个，用来存放系统内每个任务都可能访问的描述符，**例如，内核代码段、内核数据段、用户代码段、用户数据段**以及TSS（任务状态段）等都属于GDT中描述的段
	- **局部描述符表LDT**：存放某任务（即用户进程）专用的描述符
	- **中断描述符表IDT**：包含256个中断门、陷阱门和任务门描述符

通过**段寄存器**获取**段选择符**，通过**段选择符**找到**描述符表**并取出对应的**段描述符**

### 段描述符
![](../../img/Pasted%20image%2020240406232201.png)
![](../../img/Pasted%20image%2020240406232505.png)![](../../img/Pasted%20image%2020240406233059.png)
![](../../img/Pasted%20image%2020240406233137.png)
![](../../img/Pasted%20image%2020240406233405.png)
![](../../img/Pasted%20image%2020240406233421.png)
