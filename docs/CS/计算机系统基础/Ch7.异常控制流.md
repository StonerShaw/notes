## 进程
- 进程的引入为应用程序提供了以下两方面的抽象：
	- **独立的逻辑控制流**：每个进程拥有一个独立的逻辑控制流，使得程序员以为自己的程序在执行过程中独占使用处理器
	- **私有的虚拟地址空间**：每个进程拥有一个私有的虚拟地址空间，使得程序员以为自己的程序在执行过程中独占使用存储器

### 上下文切换
![](../../img/Pasted%20image%2020240406234050.png)
![](../../img/Pasted%20image%2020240406234103.png)
？？？？

### 可执行文件的加载
简单
![](../../img/Pasted%20image%2020240406234451.png)

## 异常与中断
程序执行被“中断”的事件在硬件层面有两类
- 内部“异常”：在CPU内部发生的意外事件或特殊事件。按发生原因分为**硬故障中断**和**程序性中断**两类
	- **硬故障中断**：如电源掉电、硬件线路故障等
	- **程序性中断**：执行某条指令时发生的“例外(Exception)”，如溢出、缺页、越界、越权、非法指令、除数为0、堆栈溢出、访问超时、断点设置、单步、系统调用等
- 外部“中断”：在CPU外部发生的特殊事件，通过“中断请求”信号向CPU请求处理。如实时钟、控制台、打印机缺纸、外设准备好、采样计时到、DMA传输结束等。

### 异常和中断的处理
发生异常(exception)和中断(interrupt)事件后，系统将进入OS内核态对相应事件进行处理，即改变处理器状态（用户态→内核态）
![](../../img/Pasted%20image%2020240408183346.png)

### 异常
- **故障**(fault) ：执行指令引起的异常事件，如溢出、缺页、堆栈溢出、访问超时等。
	- “断点”为发生故障指令的地址
	- 如缺页、TLB缺失
- **自陷**(Trap) ：预先安排的事件，如单步跟踪、系统调用 (执行访管指令) 等。是一种**自愿中断**
	- ”断点”为自陷指令下条指令地址
- **终止**(Abort) ：硬故障事件，此时机器将“终止”，调出中断服务程序来重启操作系统。
	- 如溢出、除数为0、非法操作、内存保护错

#### 异常举例——页故障
- 执行每条指令都要访存（取指令、取操作数、存结果）
- 在保护模式下，每次访存都要进行逻辑地址向物理地址转换
- 在地址转换过程中会发现是否发生了“页故障”
- 逻辑地址向物理地址的转换由硬件（MMU）实现，故“页故障”事件由硬件发现。所有异常和中断事件都由硬件检测发现！
- 以下情况均会发生"页故障“
	- 缺页：页表项有效位为0
	- 地址越界：地址大于最大界限
	- 访问越级或越权（保护违例）
		- **越级**：用户进程访问内核数据（CPL=3 / DPL=0）
		- **越权**：读写权限不相符（如对只读段进行了写操作）

#### 陷阱（Trap）异常
- **陷阱**也称**自陷**或**陷入**，执行陷阱指令（也称为自陷指令）时，CPU调出特定程序进行相应处理，处理结束后返回到陷阱指令的下一条指令执行。
- **陷阱的作用之一是在用户和内核之间提供一个像过程一样的接口**，这个接口称为**系统调用**，用户程序利用这个接口可方便地使用操作系统内核提供的一些服务。操作系统给每个服务编一个号，称为系统调用号。例如，Linux系统调用fork、read和execve的调用号分别是1、3和11。
- 陷阱指令异常称为编程异常（programmed exception），这些指令包括 INT n、int 3、into（溢出检查）、bound（地址越界检查）等

### 中断
- 外设通过**中断请求信号线**向CPU提出“中断”请求，不由指令引起，故中断也称为异步异常
- 每执行完一条指令，CPU就查看中断请求引脚，若**引脚的信号有效**，则进行中断响应：将当前PC（断点）和当前机器状态保存到栈中，并“关中断”，然后，从数据总线读取中断类型号，根据中断类型号跳转到对应的中断服务程序执行。中断检测及响应过程由硬件完成

#### 中断的分类
- Intel将中断分成可屏蔽中断（maskable interrupt）和不可屏蔽中断（nonmaskable interrupt，NMI）。
	- **可屏蔽中断**：通过 INTR 向CPU请求，可通过设置屏蔽字来屏蔽请求，若中断请求被屏蔽，则不会被送到CPU
	- **不可屏蔽中断**：非常紧急的硬件故障，如：电源掉电，硬件线路故障等。通过 NMI 向CPU请求。一旦产生，就被立即送CPU，以便快速处理。这种情况下，中断服务程序会尽快保存系统重要信息，然后在屏幕上显示相应的消息或直接重启系统。
	- ![](../../img/Pasted%20image%2020240408185057.png)

### 异常和中断的响应、处理
#### 异常/中断响应过程
检测到异常或中断时，CPU须进行以下基本处理：
1. **关中断**（“中断允许位” 清0）：使CPU处于“禁止中断”状态，以防止新中断破坏断点（PC）、程序状态（PSW）和现场（通用寄存器）。
2. **保护断点和程序状态**：将断点和程序状态保存到栈或特殊寄存器中
	![](../../img/Pasted%20image%2020240408185323.png)
3. **识别异常事件**：分为**软件识别**和**硬件识别**（向量中断）
	1. **软件识别**（MIPS采用）
		-  设置一个异常状态寄存器（MIPS中为Cause寄存器），用于记录异常原因。操作系统使用一个统一的异常处理程序，该程序按优先级顺序查询异常状态寄存器，识别出异常事件
	2. **硬件识别（向量中断）**（IA-32采用）
		- 用专门的硬件查询电路按优先级顺序识别异常，得到“中断类型号”，根据此号，到中断向量表中读取对应的中断服务程序的入口地址

### IA-32/Linux下的异常/中断机制
#### IA-32的中断
- 有256种不同类型的异常和中断
- 每个异常和中断都有唯一编号，称之为**中断类型号**（也称向量号）。如类型0为“除法错”，类型2为“NMI中断”，类型14为“缺页”
- 每个异常和中断有与其对应的**异常处理程序**或**中断服务程序**，其入口地址放在一个专门的**中断向量表或中断描述符表**中。
- 前32个类型（0~31）保留给CPU使用，剩余的由用户自行定义（这里的用户指机器硬件的用户，即操作系统）
- 通过执行INT n（指令第二字节给出中断类型号n，n=32~255）使CPU自动转到OS给出的中断服务程序执行
- **实模式下，用中断向量表描述**
- **保护模式下，用中断描述符表描述**
#### IA-32的中断类型
- 用户自定义类型号为32~255，部分用于可屏蔽中断，部分用于软中断
- **可屏蔽中断**通过CPU的INTR 引脚向CPU发出中断请求
- **软中断指令** INT n 被设定为一种陷阱异常，例如，Linux通过int $0x80指令将128号设定为系统调用，而Windows通过int $0x2e指令将46号设定为系统调用。
![](../../img/Pasted%20image%2020240408190531.png)

#### 实地址
![](../../img/Pasted%20image%2020240408190702.png)
![](../../img/Pasted%20image%2020240408191002.png)

#### 保护模式下的中断描述符表
- **段选择符**用来指示异常处理程序或中断服务程序所在段的段描述符在**GDT**中的位置，其RPL=0；
- **偏移地址**则给出异常处理程序或中断服务程序第一条指令所在偏移量。
- ![](../../img/Pasted%20image%2020240408191653.png)
- P：Linux总把P置1。DPL：访问本段要求的最低特权级。主要用于防止恶意应用程序通过 INT n 指令模拟非法异常而进入内核态执行破坏性操作

#### IA-32中异常和中断响应过程
1. 确定中断类型号 i，从 IDTR 指向的 IDT 中取出第 i 个表项 IDTi。
2. 根据 IDTi 中段选择符，从 GDTR 指向的 GDT 中取出相应段描述符，得到对应异常或中断处理程序所在段的 DPL、基地址等信息。Linux下中断门和陷阱门对应的即为内核代码段，所以DPL为0，基地址为0。
3. 若**CPL<DPL**或**编程异常 IDTi 的 DPL<CPL**，则发生13号异常。Linux下，前者不会发生。后者用于防止恶意程序模拟 INT n 陷入内核进行破坏性操作。
4. 若CPL≠DPL，则从用户态换至内核态，以使用内核栈。切换栈的步骤：
	1. 读 TR 寄存器，以访问正在运行的用户进程的 TSS段；
	2. . 将 TSS段中保存的内核栈的段选择符和栈指针分别装入寄存器 SS 和 ESP，然后在内核栈中保存原来用户栈的 SS 和 ESP。
5. 若是故障，则将发生故障的指令的逻辑地址写入 CS 和 EIP，以使处理后回到故障指令执行。其他情况下，CS 和 EIP 不变，使处理后回到下条指令执行。
6. 在当前栈中保存 EFLAGS、CS 和 EIP 寄存器的内容（断点和程序状态）。
7. 若异常产生了一个硬件出错码，则将其保存在内核栈
8. 将IDTi中的段选择符装入CS，IDTi中的偏移地址装入EIP，它们是异常处理程序或中断服务程序第一条指令的逻辑地址（Linux中段基址=0）。

#### IA-32中异常和中断返回过程
中断或异常处理程序最后一条指令是IRET。CPU在执行IRET指令过程中完成以下工作：
1. 从栈中弹出硬件出错码（保存过的话）、EIP、CS和EFLAGS
2. 检查当前异常或中断处理程序的CPL是否等于CS中最低两位，若是则说明异常或中断响应前、后都处于同一个特权级，IRET指令完成操作；否则，再继续完成下一步工作。
3. 从内核栈中弹出SS和ESP，以恢复到异常或中断响应前的特权级进程所使用的栈。
4. 检查DS、ES、FS和GS段寄存器的内容，若其中有某个寄存器的段选择符指向一个段描述符且其DPL小于CPL，则将该段寄存器清0。这是为了防止恶意应用程序（CPL=3）利用内核以前使用过的段寄存器（DPL=0）来访问内核地址空间。
执行完IRET指令后，CPU回到原来发生异常或中断的进程继续执行

#### Linux中的异常和中断处理
- Linux利用**陷阱门来处理异常，利用中断门来处理中断**
- 异常和中断对应处理程序都属于内核代码段，所以，**所有中断门和陷阱门的段选择符(0x60)都指向 GDT 中的“内核代码段”描述符。**
- 通过中断门进入到一个中断服务程序时，CPU 会清除 EFLAGS 寄存器中的 IF 标志，即关中断；通过陷阱门进入一个异常处理程序时，CPU 不会修改 IF 标志。也就是说，**外部中断不支持嵌套处理，而内部异常则支持嵌套处理。**
- **任务门描述符**中不包含偏移地址，只包含 TSS 段选择符，这个段选择符指向 GDT 中的一个 TSS 段描述符，CPU 根据 TSS 段中的相关信息装载 EIP 和 ESP 等寄存器，从而执行相应的异常处理程序
- Linux中，将类型号为8的双重故障（#DF）用任务门实现，而且是唯一通过任务门实现的异常。
#### Linux中中断描述符表的初始化
   CPU负责对异常和中断的检测与响应，而**操作系统则负责初始化 IDT 以及编制好异常处理程序或中断服务程序**。Linux运用提供的三种门描述符格式，构造了以下5种类型的门描述符。
   1. **中断门**：DPL=0，TYPE=1110B。激活所有中断
   2. **系统门**：DPL=3，TYPE=1111B。激活4、5和128三个陷阱异常，分别对应指令into、bound和int $0x80三条指令。因DPL为3，CPL≤DPL，故在用户态下可使用这三条指令
   3. **系统中断门**：DPL=3，TYPE=1110B。激活3号中断（即调试断点），对应指令int 3。因DPL为3，CPL≤DPL，故用户态下可使用int 3指令
   4. **陷阱门**：DPL=0，TYPE=1111B。激活所有内部异常，并阻止用户程序使用INT n（n≠128或3）指令模拟非法异常来陷入内核态运行
   5. **任务门**：DPL=0，TYPE=0101B。激活8号中断（双重故障）。

#### Linux中对异常的处理
![](../../img/Pasted%20image%2020240408193820.png)
所有异常处理程序的结构是一致的，都可划分成以下三个部分：
1. 准备阶段：在内核栈保存通用寄存器内容（称为现场信息），这部分大多用汇编语言程序实现。
2. 处理阶段：采用C函数进行具体处理。函数名由do_前缀和处理程序名组成，如 do_overflow 为溢出处理函数。
	- 大部分函数的处理方式：保存硬件出错码（如果有的话）和异常类型号，然 后，向当前进程发送一个信号。
	- 当前进程接受到信号后，若有对应信号处理程序，则转信号处理程序执行；若没有，则调用内核abort例程执行，以终止当前进程。
	- 恢复阶段：恢复保存在内核栈中的 
3. 各个寄存器的内容，切换到用户态并 返回到当前进程的断点处继续执行
#### Linux中对中断的处理
- 对于大部分异常，Linux只是给引起异常的当前进程发送一个信号就结束异常处理，具体的异常处理转到信号处理程序进行。
- 对于中断，因为中断事件的发生与正在执行的当前进程很可能没有关系，所以将一个信号发给当前进程没有意义。
- Linux中有三种类型中断。1. I/O中断：I/O外设的中断请求；2. 时钟中断：某时钟产生的中断请求，告知固定时间间隔到；3. 处理器中断：多处理器系统中其他处理器发出的中断请求。后两种超出了本教材范围
- I/**O中断**：每个能发中断请求的外设控制器都有一条IRQ线，所有IRQ线连接到一个可编程中断控制器PIC （Programmable Interrupt Controller）中对应的IRQ引脚上，PIC中每个IRQ引脚（来自中断源）都有一个编号，如IRQ0、IRQ1、…、IRQi、…，可将与 IRQi 关联的中断类型号设定为32+i。

- PIC需对所有外设来的 IRQ请求按优先级排队，若至少有一个IRQ线有请求且未被屏蔽，则 PIC向 CPU的 INTR引脚发中断请求。
- CPU每执行完一条指令都会查询 INTR，若发现有中断请求，则进入中断响应过程，调出中断服务程序执行。

所有中断服务程序的结构类似，都划分为以下三个阶段。
1. 准备阶段：在内核栈中保存各通用寄存器的内容（称为现场信息）以及所请求 IRQi 的值等，并给PIC回送应答信息，允许其发送新的中断请求信号。
2. 处理阶段：执行 IRQi 对应的中断服务例程 ISR （Interrupt Server Routine）。中断类型号为32+i
3. 恢复阶段：恢复保存在内核栈中的各个寄存器的内容，切换到用户态并返回到当前进程的逻辑控制流的断点处继续执行。
#### IA-32/Linux的系统调用
- **系统调用号**是**系统调用跳转表**索引值，表中给出**系统调用服务例程**首址
- 通常，系统调用被封装成用户程序能直接调用的函数，如exit()、read()和open()，这些是标准C库中系统调用对应的封装函数 。
- **Linux中系统调用所用参数通过寄存器传递**，传递参数的寄存器顺序依次为：EAX（**调用号**）、EBX、ECX、EDX、ESI、EDI和EBP，除调用号以外，最多6个参数。
- ![](../../img/Pasted%20image%2020240408194719.png)
- ![](../../img/Pasted%20image%2020240408195542.png)
- 中断->取IDT表项->check表项DPL，要求DPL>=CPL->切换内核态->装入IDT表项（选择符 与 偏移）